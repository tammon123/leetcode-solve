# 贪心
## 方法一(贪心)：
### 思路
1. 由于字符只有`x,y`，那么当前除了$s1[i]==s2[i]$以外，只会存在$xy,yx$这两种组合。
   - 首先考虑，如果之前组合为$xy$，当前组合还是$xy$，那么我们只需要交换前面组合的$x$与后面组合的$y$，一次交换后有，$yy$与$xx$，匹配。
    ```
    x x   交换后有 y x
    y y           y x
    ```

    同理，$yx$与$yx$组合也需要一步操作就能匹配。
    - 如果之前组合为$xy$，当前组合为$yx$，那么我们需要两步操作，先交换一次让他们成对，然后再交换一次匹配。
    ```
    x y 交换后成对 y y 再交换匹配 x y
    y x           x x           x y
    ```

2. 由上可知，加入有$cnt1$个$xy$，$cnt2$个$yx$，根据贪心的想法，我们让成对的先匹配，需要的操作数为$\frac{cnt1}{2}+\frac{cnt2}{2}$，那么剩余的互相成对，那么如果和为奇数，最终$s1$不能匹配上$s2$，否则需要操作数为$cnt1 \%2+cnt2\%2$

### 复杂度
- 时间复杂度:
  > $O(n)$，$n$为字符串$s1,s2$的长度
- 空间复杂度:
  > $O(1)$

没优化代码：
### Code
```C++ []
class Solution {
public:
    int minimumSwap(string s1, string s2) {
        int cnt1 = 0, cnt2 = 0, n = s1.size();
        for (int i = 0;i < n;++i) {
            if (s1[i] == 'x' && s2[i] == 'y') ++cnt1;
            else if (s1[i] == 'y' && s2[i] == 'x') ++cnt2;
        }
        if ((cnt1 + cnt2) % 2 == 1) return -1;
        return cnt1 / 2 + cnt2 / 2 + cnt1 % 2 + cnt2 % 2;
    }
};
```
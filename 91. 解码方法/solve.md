# 动态规划
## 方法一(动态规划)：
### 思路
1. 假设$dp[i]$表示字符串前$i$个字符的解码总数。我们考虑状态转移，最后依次解码字符的情况：
   - 情况一，我们使用一个字符。假设$s[i]\neq 0$，可以被解码成$A-I$，那么前$i-1$的解码数量为$dp[i-1]$，那么状态转移方程有：$dp[i]+=dp[i-1],s[i]\neq0$
   - 情况二，我们使用两个字符。假设$s[i-1]\neq0$，并且$s[i-1]$与$s[i]$组成的整数应该小于等于$26$，这样可以被解码成$J-Z$，由于前$i-2$的解码数量为$dp[i-2]$，那么状态转移方程有:$dp[i]+=dp[i-2],s[i-1]\neq0,10*s[i-1]+s[i]<=26$
2. 边界条件，当字符串为空时，解码数为$1$，即$dp[0]=1$。因为空字串解码出来是空字符串。

### 复杂度
- 时间复杂度:
  > $O(n)$，$n$为字符串$s$的大小
- 空间复杂度:
  > $O(n)$，数组存储状态转移需要$O(n)$

### Code
```C++ []
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int i = 1;i < n + 1;++i) {
            if (s[i - 1] != '0') dp[i] += dp[i - 1];
            if (i > 1 && s[i - 2] != '0' && 10 * (s[i - 2] - '0') + (s[i - 1] - '0') <= 26) dp[i] += dp[i - 2];
        }
        return dp[n];
    }
};
```
## 方法二(状压DP)：
### 思路
1. 因为状态转移过程，$dp[i]$只由$dp[i-1]$与$dp[i-2]$转移而来，可用三个变量进行压缩

### 复杂度
- 时间复杂度:
  > $O(n)$，$n$为字符串$s$的大小
- 空间复杂度:
  > $O(1)$，状压只需几个变量

### Code
```C++ []
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size(), a = 0, b = 1, c;
        for (int i = 1;i <= n;++i) {
            c = 0;
            if (s[i - 1] != '0') c += b;
            if (i > 1 && s[i - 2] != '0' && 10 * (s[i - 2] - '0') + (s[i - 1] - '0') <= 26) c += a;
            tie(a, b) = make_pair(b, c);
        }
        return c;
    }
};
```
# 贪心
## 方法一(贪心)：
### 思路
1. 当前最大能到达的位置为$maxPos=max(maxPos, nums[i]+i)$，在最大位置能都能随便到达，我们从左往右依次更新最大位置。我们每一步都以最大位置作为结束点，当到达结束点时候，重新统计下一步需要到达最大位置的结束点。例如：$nums = [2,3,1,1,4]$，以第一点出发，我们能到达的最大距离为下标为$endPos=nums[0]+0=2$的点，在这点内的所有点，都是第一步能到达的。过程中，最远距离会在下标为$1$的时候，更新为$maxPos=nums[1]+1=4$，即：再第一步到达下标$1$位置，最远距离到了$n-1$。我们从左往右遍历到初始$0$点能到达的最远下标$2$时候，计算更新下一个结束点最远距离$endPos=n-1$，步长加一。然而并不需要遍历到$n-1$，因为遍历到$n-1$时会重新更新下一个结束点并让步长加一，所以只需要遍历到$n-2$。那么由于以上操作，最大步长便为$2$

### 复杂度
- 时间复杂度:
  > $O(n)$，$n$为数组$nums$的大小
- 空间复杂度:
  > $O(1)$

### Code
```C++ []
class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size(), maxPos = 0, endPos = 0, ans = 0;
        for (int i = 0;i < n - 1;++i) {
            maxPos = max(maxPos, nums[i] + i);
            if (endPos == i) {
                endPos = maxPos;
                ++ans;
            }
        }
        return ans;
    }
};
```
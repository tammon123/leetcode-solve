# 动态规划
## 方法一(动态规划)：
### 思路
1. 因为整数$n$由最少$2$个正整数的和拆分而得。假设整数拆分为$x$与$n-x$，$n-x$可以不拆分或者继续拆分。因而，拆分和的最大乘积问题可以转化为动态规划问题

2. 假设$dp[i]$表示整数$i$被拆分后的最大乘积。那么需要考虑两种情况：
   - 假设当前拆分的值为$j$与$i-j$，$i-j$不能再拆分了，此时的乘积为$j*(i-j)$
   - $i-j$如果还能拆分，此时的乘积为$j*dp[i-j]$
   - 因为最少两个正整数，那么在$1<=j<i$范围中找到，乘积最大的值，即:$dp[i]=\max\limits_{1<=j<i}\{\max(j*(i-j),j*dp[i-j])\}$

3. 边界条件，因为$0$不属于正整数，$1$不能拆分成最少两个正整数，所以$dp[0]=dp[1]=0$

### 复杂度
- 时间复杂度:
  > $O(n^2)$，$n$为给定的正整数，对于$2$到$n$的正整数都要计算$dp$状态值，$dp$状态值需要$O(n)$时间，所以最终需要$O(n^2)$
- 空间复杂度:
  > $O(n)$，需要存储一个长为$n$的状态数组

### Code
```C++ []
class Solution {
public:
    int integerBreak(int n) {
        vector<int> products(n + 1);
        for (int i = 2;i <= n;++i) {
            for (int j = 1;j < i;++j) {
                products[i] = max(products[i], max(j * (i - j), products[i - j] * j));
            }
        }
        return products[n];
    }
};
```
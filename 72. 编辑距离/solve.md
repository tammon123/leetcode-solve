# 动态规划
## 方法一(动态规划)：
### 思路
1. 每个字符串有三种操作，两个字符串有$6$种搭配。但其实有三种情况是等价的：
   - 字符串$word1$删除字符，与字符串$word2$增加字符等价。例如：$word1="abc"，word2="ab"$，那么$word1$删除最后一个字符与$word2$在末尾添加字符$'c'$等价
   - 同理字符串$word1$添加字符与字符串$word2$删除字符等价
   - 字符串$word1$替换字符与字符串$word2$替换字符等价。例如：$word1="abc"，word2="abd"$，那么$word1$末尾字符$'c'$替换为$'d'$与$word2$末尾字符$'d'$替换为$'c'$是等价的
   - 那么最终只有三种情况：
      - 字符串$word1$插入字符
      - 字符串$word2$插入字符
      - 替换字符串$word1$的字符

2. 这样就可以将问题转化为子问题了。假如$word1="horse",word2="ros"$
   - **字符串$word1$插入字符**：如果我们知道$"horse"$到$"ro"$的编辑距离为$a$，那么我们只需要在$word1$后插入字符$'s'$就能让两字符串相等，即需要$a+1$次操作
   - **字符串$word2$插入字符**：我们知道$"hors"$到$"ros"$的编辑距离为$b$，跟上面一样，需要$b+1$次操作
   - **替换字符串$word1$的字符**：我们知道$"hors"$到$"ro"$的编辑距离为$c$，同样道理$word1$末尾$'e'$替换为$'s'$就能让两字符串相等，即需要$c+1$次操作
   - 那么字符串$word1$与$word2$相等最少操作数为$min(a+1,b+1,c+1)$
   - 三种情况的顺序不会影响最终结果

3. 我们用动态规划解决问题，我们设$dp[i][j]$表示$word1$的前$i$个字符与$word2$的前$j$个字符的编辑距离。我们考虑三个情况，分别为$dp[i-1][j],dp[i][j-1],dp[i-1][j-1]$。
    - $dp[i-1][j]$表示$word1$的前$i-1$个字符与$word2$的前$j$个字符的编辑距离。那么对于$word1$的$i$字符，我们只需要$word2$末尾添加相同字符，那么编辑距离最小为$dp[i-1][j]+1$
    - $dp[i][j-1]$表示$word1$的前$i$个字符与$word2$的前$j-1$个字符的编辑距离。那么对于$word2$的$j$字符，我们只需要$word1$末尾添加相同字符，那么编辑距离最小为$dp[i][j-1]+1$
    - $dp[i-1][j-1]$表示$word1$的前$i-1$个字符与$word2$的前$j-1$个字符的编辑距离。那么对于$word1$的$i$字符，我们替换成$word2$的$j$字符，那么编辑为$dp[i-1][j-1]+1$。但假如$word1$第$i$字符与$word2$第$j$字符相等，不需要替换，那么编辑距离为$dp[i-1][j-1]$。

4. 最终转移方程有: 
   - $dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+1)，word1[i-1]=word2[j-1]$
   - $dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1])，word1[i-1]\neq word2[j-1]$

5. 边界条件:任意一方为空字符串时，编辑距离应该为另一方字符串长度，即:$dp[i][0]=i,dp[0][j]=j$

### 复杂度
- 时间复杂度:
  > $O(mn)$，$m$为字符串$word1$的长度，$n$为字符串$word2$的长度
- 空间复杂度:
  > $O(mn)$，需要存储一个大小为$mn$的状态数组

### Code
```C++ []
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, m + n));
        for (int i = 0;i <= m;++i) dp[i][0] = i;
        for (int j = 0;j <= n;++j) dp[0][j] = j;

        for (int i = 1;i <= m;++i) {
            for (int j = 1;j <= n;++j) {
                int x = dp[i - 1][j] + 1;
                int y = dp[i][j - 1] + 1;
                int z = dp[i - 1][j - 1] + 1;
                if (word1[i - 1] == word2[j - 1]) --z;
                dp[i][j] = min(x, min(y, z));
            }
        }
        return dp[m][n];
    }
};
```
